////  KAButtonBlackFadeDrawer.m//  AiOControlIBPlugin////  Created by Edward.Chen on 11/11/09.//  Copyright 2009 yoyokko. All rights reserved.////  Redistribution and use in source and binary forms, with or without modification,//  are permitted provided that the following conditions are met:////		Redistributions of source code must retain the above copyright notice, this//	list of conditions and the following disclaimer.////		Redistributions in binary form must reproduce the above copyright notice,//	this list of conditions and the following disclaimer in the documentation and/or//	other materials provided with the distribution.////		Neither the name of the BinaryMethod.com nor the names of its contributors//	may be used to endorse or promote products derived from this software without//	specific prior written permission.////	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND//	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED//	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.//	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,//	INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,//	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,//	OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,//	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)//	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE //	POSSIBILITY OF SUCH DAMAGE.#import "KAButtonGrayDrawer.h"#import "KAGradient.h"#import "NSBezierPath+RoundedRect.h"static float BtnCenterX(NSRect aRect) {	return (aRect.size.width / 2);}static float BtnCenterY(NSRect aRect) {	return (aRect.size.height / 2);}@implementation KAButtonGrayDrawer/*! @function @abstract   drawer @discussion This class method should return a auto release object of itself. @param      nil @result     The autorelease object of self. */+ (id<IControlDrawer>) drawer{	return [[[self alloc] init] autorelease];}/*! @function	 @abstract   Draw the presentation of the control specified in the args. @discussion Draw the presentation of the control specified in the args. @param      control The control which implements protocol IPresentationSeparated @param		args The presentation args. @result     The function return void. */- (void) DrawControl:(id<IPresentationSeparated>) control Args:(PresentationArgs *)args{	buttonCell = (KAButtonCell *) control;	_normalImage = [buttonCell privateNormalImage];		NSRect cellFrame = [args m_ClipRectangle];	NSView *controlView = [[args m_PresentationInfo] controlView];		cellFrame.size.height = [buttonCell cellSize].height;	switch ([buttonCell bezelStyle]) {					case NSTexturedRoundedBezelStyle:			[self drawTexturedRoundedButtonInFrame: cellFrame];			break;		case NSRoundRectBezelStyle:			[self drawRoundRectButtonInFrame: cellFrame];			break;		case NSSmallSquareBezelStyle:			[self drawSmallSquareButtonInFrame: cellFrame];			break;		case NSRoundedBezelStyle:			[self drawRoundedButtonInFrame: cellFrame inView: controlView];			break;		case NSHelpButtonBezelStyle:			[self drawHelpButtonInFrame: cellFrame];			break;		case NSRegularSquareBezelStyle:			[self drawHyperLinkButtonInFrame: cellFrame];			break;		default:			break;	}		if([[_normalImage name] isEqualToString: @"NSSwitch"] ||	   [[_normalImage name] isEqualToString: @"NSRadioButton"] ||	   [[[buttonCell controlView] className] isEqualToString: @"NSMatrix"])	{				if([buttonCell imagePosition] != NSNoImage) {			[self drawImage: [buttonCell image] withFrame: cellFrame inView: [buttonCell controlView]];		}		return;	}	}#pragma mark  Colors- (NSColor *)colorVlaueWithRed: (int)red green: (int)green blue: (int)blue{	return [NSColor colorWithDeviceRed: red/255.0 green: green/255.0 blue: blue/255.0 alpha: 1.0f];}-(float)alphaValue {		return 0.6f;}-(float)disabledAlphaValue {		return 0.2f;}-(NSColor *)normalGraySolidFill {		return [NSColor grayColor];//[NSColor colorWithDeviceRed: 0.141f green: 0.141f blue: 0.141f alpha: [self alphaValue]];}-(NSColor *)normalDarkSolidFill {		return [NSColor colorWithDeviceRed: 0.141f green: 0.141f blue: 0.141f alpha: 1.0f];}- (void)drawShadingWithStartingColor: (NSColor *)startingColor withEndingColor: (NSColor*)endingColor inBezierPath: (NSBezierPath* )path{	KAGradient *mygradient = [[[KAGradient alloc] initWithStartingColor: startingColor															endingColor: endingColor] autorelease];	[mygradient drawInBezierPath:path angle: 90];}-(NSColor *)strokeColor {		return [NSColor colorWithDeviceRed: 0.749f green: 0.761f blue: 0.788f alpha: 1.0f];}-(NSShadow *)dropShadow {		NSShadow *shadow = [[NSShadow alloc] init];	[shadow setShadowColor: [NSColor blackColor]];	[shadow setShadowBlurRadius: 2];	[shadow setShadowOffset: NSMakeSize( 0, -1)];		return [shadow autorelease];}-(NSColor *)darkStrokeColor {		return [NSColor colorWithDeviceRed: 0.141f green: 0.141f blue: 0.141f alpha: 0.5f];}-(NSColor *)highlightSolidFill {		return [NSColor colorWithDeviceRed: 0.941f green: 0.941f blue: 0.941f alpha: [self alphaValue]];}-(NSColor *)disabledNormalSolidFill {		return [self colorVlaueWithRed: 162 green: 162 blue: 162];}-(NSColor *)pushedSolidFill {	return [NSColor redColor];}#pragma mark Drawing Methods- (void) drawHyperLinkButtonInFrame:(NSRect)frame{	if([[_normalImage name] isEqualToString: @"NSSwitch"]) {				//[self drawCheckInFrame: frame isRadio: NO];			} else if([[_normalImage name] isEqualToString: @"NSRadioButton"] || [[[buttonCell controlView] className] isEqualToString: @"NSMatrix"]) {				//[self drawCheckInFrame: frame isRadio: YES];	} else {		NSMutableAttributedString *hyperLinkString = [[buttonCell attributedTitle] mutableCopy];		NSRange selectedRange = {0, [hyperLinkString length]};				[hyperLinkString beginEditing];				[hyperLinkString addAttribute:NSForegroundColorAttributeName								value:[NSColor colorWithCalibratedRed:0.8086 green:0.8086 blue:0.8086 alpha:1.0]								range:selectedRange];				[hyperLinkString addAttribute:NSUnderlineStyleAttributeName								value:[NSNumber numberWithInt:NSSingleUnderlineStyle]								range:selectedRange];		[hyperLinkString endEditing];				[hyperLinkString drawInRect:frame];				[hyperLinkString release];	}}-(void)drawRoundedButtonInFrame:(NSRect)frame inView: (NSView *)controlView{		NSRect textFrame;		//Adjust Rect so strokes are true and	//shadows are visible	frame.origin.x += .5f;	frame.origin.y += .5f;	frame.size.height -= 1;	frame.size.width -= 1;		//Adjust Rect based on ControlSize so that	//my controls match as closely to apples	//as possible.	switch ([buttonCell controlSize]) {		default: // Silence uninitialized variable warnings for textFrame fields.		case NSRegularControlSize:						frame.origin.x += 4;			frame.origin.y += 4;			frame.size.width -= 8;			frame.size.height -= 12;						textFrame = frame;			break;					case NSSmallControlSize:						frame.origin.x += 4;			frame.origin.y += 4;			frame.size.width -= 8;			frame.size.height -= 11;						textFrame = frame;			textFrame.origin.y += 1;			break;					case NSMiniControlSize:						frame.origin.y -= 1;						textFrame = frame;			textFrame.origin.y += 1;			break;	}		//Create Path	NSBezierPath *path = [[NSBezierPath alloc] init];	/*	 [path appendBezierPathWithArcWithCenter: NSMakePoint(NSMinX(frame) + BtnCenterY(frame), NSMidY(frame) + 0.5f)	 radius: BtnCenterY(frame)	 startAngle: 90	 endAngle: 270];	 	 [path appendBezierPathWithArcWithCenter: NSMakePoint(NSMaxX(frame) - BtnCenterY(frame), NSMidY(frame) + 0.5f)	 radius: BtnCenterY(frame) 	 startAngle: 270 	 endAngle: 90];	 	 [path closePath];	 */	[path appendBezierPathWithRoundedRect: frame cornerRadius:6.0f];	if([buttonCell isEnabled]) {				if(([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 14) ||		   ([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 12)) 		{						if([buttonCell state] == 1) {								[[self highlightSolidFill] set];				[path fill];			} else {								[self drawShadingWithStartingColor: [self colorVlaueWithRed: 239 green: 239 blue: 239]//[NSColor blackColor]								   withEndingColor: [self colorVlaueWithRed: 93 green: 93 blue: 93]//[NSColor whiteColor]									  inBezierPath: path];								/*NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"graybutton.png"];				 NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];				 [buttonImage drawInRect:frame fromRect: NSZeroRect operation: NSCompositeSourceAtop fraction:1.0];					 [buttonImage release];*/								//[[self normalGraySolidFill] set];								//[path fill];			}		} 		else 		{						if([buttonCell isHighlighted])			{				[self drawShadingWithStartingColor: [self colorVlaueWithRed: 239 green: 239 blue: 239]//[NSColor blackColor]								   withEndingColor: [self colorVlaueWithRed: 93 green: 93 blue: 93]//[NSColor whiteColor]									  inBezierPath: path];								[[self colorVlaueWithRed: 246 green: 186 blue: 55] set];				[path setLineWidth: 3.0f];				[path stroke];							} 			else			{				//It's default button?				id btnControl = [buttonCell controlView];				if ([btnControl respondsToSelector: @selector(keyEquivalent)] && ![[btnControl keyEquivalent] isEqualToString: @"\r"])				{					[self drawShadingWithStartingColor: [self colorVlaueWithRed: 239 green: 239 blue: 239]//[NSColor blackColor]									   withEndingColor: [self colorVlaueWithRed: 93 green: 93 blue: 93]//[NSColor whiteColor]										  inBezierPath: path];				}				else				{					[self drawShadingWithStartingColor: [self colorVlaueWithRed: 239 green: 239 blue: 239]//[NSColor blackColor]									   withEndingColor: [self colorVlaueWithRed: 93 green: 93 blue: 93]//[NSColor whiteColor]										  inBezierPath: path];					//Check whether button clicked					NSEvent *event = [NSApp currentEvent];					if (event &&						([event type] == NSLeftMouseDown) &&						![buttonCell isHighlighted])					{						NSWindow *win = [event window];						if (win && [win isKeyWindow])						{							NSView *view = [win contentView];							[buttonCell setMIsFound:NO];							[buttonCell travelSubViews: view];						}					}					if (![buttonCell mIsFound])					{						[NSGraphicsContext saveGraphicsState];						[[self colorVlaueWithRed: 246 green: 186 blue: 55] set];						[path setLineWidth: 3.0f];						[path stroke];						[NSGraphicsContext restoreGraphicsState];					}					else						[buttonCell setMIsFound:NO];				}				//[path fill];			}		}	} else {				[self drawShadingWithStartingColor: [self colorVlaueWithRed: 220 green: 220 blue: 220]//[NSColor blackColor]						   withEndingColor: [self colorVlaueWithRed: 112 green: 112 blue: 112]//[NSColor whiteColor]							  inBezierPath: path];	}		[path release];		if([buttonCell imagePosition] != NSImageOnly) {				[self drawTitle: [buttonCell attributedTitle] withFrame: textFrame inView: [buttonCell controlView]];	}		if([buttonCell imagePosition] != NSNoImage) {				[self drawImage: [buttonCell image] withFrame: frame inView: [buttonCell controlView]];	}}-(void)drawCheckInFrame:(NSRect)frame isRadio:(BOOL)radio{	//Adjust by .5 so lines draw true	frame.origin.x += .5f;	frame.origin.y += .5f;		if([[[buttonCell controlView] className] isEqualToString: @"NSMatrix"])	{				NSMatrix* matrix = (NSMatrix*)[buttonCell controlView];		frame.origin.y += ((BtnCenterY([matrix bounds]) / [matrix numberOfRows]) - BtnCenterY(frame));	} 	else if(![[[buttonCell controlView] className] isEqualToString: @"KATableView"] &&			![[[buttonCell controlView] className] isEqualToString: @"KAOutlineView"]) {				frame.origin.y += (BtnCenterY([[buttonCell controlView] bounds]) - BtnCenterY(frame));	}		// Create Check Rect	NSRect innerRect = frame;	NSRect textRect = frame;	//Make adjustments based on ControlSize	//Set checkbox size	if([buttonCell controlSize] == NSRegularControlSize) {		/*innerRect.size.height = 12;		 innerRect.size.width = 13;		 innerRect.origin.y += 2;*/				innerRect.size.height = 10;		innerRect.size.width = 11;		innerRect.origin.y += 2;			} else if([buttonCell controlSize] == NSSmallControlSize) {				innerRect.size.height = 10;		innerRect.size.width = 11;		innerRect.origin.y += 3;			} else {				innerRect.size.height = 8;		innerRect.size.width = 9;		innerRect.origin.y += 5;	}		if(radio) {		innerRect.size.height = innerRect.size.width;	}		// Determine Horizontal Placement	switch ([buttonCell imagePosition]) {					case NSImageLeft:						//Make adjustments to horizontal placement			//Create Text Rect so text is drawn properly			if([buttonCell controlSize] == NSRegularControlSize) {								innerRect.origin.x += 2;				textRect.size.width -= (NSMaxX(innerRect) + 5);				textRect.origin.x = (NSMaxX(innerRect) + 5);				textRect.origin.y -= 2;							} else if([buttonCell controlSize] == NSSmallControlSize) {								innerRect.origin.x += 3;				textRect.size.width -= (NSMaxX(innerRect) + 6);				textRect.origin.x = (NSMaxX(innerRect) + 6);				textRect.origin.y -= 1;							} else {								innerRect.origin.x += 4;				textRect.size.width -= (NSMaxX(innerRect) + 4);				textRect.origin.x = (NSMaxX(innerRect) + 4);			}						break;					case NSImageOnly:						//Adjust slightly so lines draw true, and center really is			//center			if([buttonCell controlSize] == NSRegularControlSize) {								innerRect.origin.x -= .5f;			} else if([buttonCell controlSize] == NSMiniControlSize) {								innerRect.origin.x += .5f;			}						innerRect.origin.x += BtnCenterX(frame) - BtnCenterX(innerRect);			break;					case NSImageRight:						if([buttonCell controlSize] == NSRegularControlSize) {								innerRect.origin.x = (NSWidth(frame) - NSWidth(innerRect) - 1.5f) ;				textRect.origin.x += 2;				textRect.size.width = (NSMinX(innerRect) - NSMinX(textRect) - 5);				textRect.origin.y -= 2;							} else if([buttonCell controlSize] == NSSmallControlSize) {								innerRect.origin.x = (NSWidth(frame) - NSWidth(innerRect) - 1.5f);				textRect.origin.x += 2;				textRect.size.width = (NSMinX(innerRect) - NSMinX(textRect) - 5);				textRect.origin.y -= 1;							} else {								innerRect.origin.x = (NSWidth(frame) - NSWidth(innerRect) - 1.5f);				textRect.origin.x += 2;				textRect.size.width = (NSMinX(innerRect) - NSMinX(textRect) - 5);			}						break;					case NSImageBelow:						break;					case NSImageAbove:						break;					case NSImageOverlaps:						break;	}		// Draw Glyphs for On/Off/Mixed States	switch ([buttonCell state])	{		case NSOffState:			if (radio)			{				if ([buttonCell isEnabled])				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"radiobutton.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];										}				else				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"radiobuttonda.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];					}			}			else			{				if ([buttonCell isEnabled])				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"checkbox.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];				}				else				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"checkboxda.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];					}							}			break;		case NSOnState:			if(radio)			{				if ([buttonCell isEnabled])				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"radiobuttonsl.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];					}				else 				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"radiobuttonslda.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];						}						} 			else			{				if ([buttonCell isEnabled])				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"checkboxsl.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];					}				else 				{					NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"checkboxslda.png"];					NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];					[buttonImage setFlipped: YES];					[buttonImage drawInRect:innerRect fromRect: NSZeroRect operation: NSCompositeSourceOver fraction:1.0];						[buttonImage release];						}										}			break;	}		if([buttonCell imagePosition] != NSImageOnly) {				if([buttonCell attributedTitle]) {						[self drawTitle: [buttonCell attributedTitle] withFrame: textRect inView: [buttonCell controlView]];		}	}}- (void)drawImage:(NSImage *)image withFrame:(NSRect)frame inView:(NSView *)controlView{		if(NO/*[image isTemplate]*/) {		//[super drawImage: image withFrame: frame inView: controlView];	} else {				//Ugly hack to determine if this is a Check or Radio button.		//Apple uses Images for the check and radio buttons, this is		//a very ugly hack to detect which one is being used so that		//I can draw the correct one.		if([[_normalImage name] isEqualToString: @"NSSwitch"]) {						[self drawCheckInFrame: frame isRadio: NO];				} else if([[_normalImage name] isEqualToString: @"NSRadioButton"] || [[[buttonCell controlView] className] isEqualToString: @"NSMatrix"]) {						[self drawCheckInFrame: frame isRadio: YES];		} else {						//Setup per State and Highlight Settings			if([buttonCell showsStateBy] == 0 && [buttonCell highlightsBy] == 1) {								if([buttonCell isHighlighted]) {										if([buttonCell alternateImage]) {						image = [buttonCell alternateImage];					}				}			}						if([buttonCell showsStateBy] == 1 && [buttonCell highlightsBy] == 3) {								if([buttonCell state] == 1) {										if([buttonCell alternateImage]) {						image = [buttonCell alternateImage];					}				}			}						//Calculate Image Position			NSRect imageRect = frame;			imageRect.size.height = [image size].height;			imageRect.size.width = [image size].width;			imageRect.origin.y += (frame.size.height /2) - (imageRect.size.height /2);						//Setup Position			switch ([buttonCell imagePosition]) {									case NSImageLeft:										imageRect.origin.x += 5;					break;									case NSImageOnly:										imageRect.origin.x += (frame.size.width /2) - (imageRect.size.width /2);					break;									case NSImageRight:										imageRect.origin.x = ((frame.origin.x + frame.size.width) - imageRect.size.width) - 5;					break;									case NSImageBelow:										break;									case NSImageAbove:										break;									case NSImageOverlaps:										break;									default:										imageRect.origin.x += 5;					break;			}						[image setFlipped: YES];						//Draw the image based on enabled state			if([buttonCell isEnabled]) {								[image drawInRect: imageRect fromRect: NSZeroRect operation: NSCompositeSourceAtop fraction: 0.6f];			} else {				[image drawInRect: imageRect fromRect: NSZeroRect operation: NSCompositeSourceAtop fraction: 0.2f];			}					}	}}-(void)drawSmallSquareButtonInFrame:(NSRect)frame {		//Adjust Rect so strokes are true and	//shadows are visible	frame.origin.x += 1.5f;	frame.origin.y += 0.5f;	frame.size.width -= 3;	frame.size.height = [[buttonCell controlView] bounds].size.height - 3;		//Draw Outer-most ring	NSBezierPath *path = [[NSBezierPath alloc] init];	[path appendBezierPathWithRect: frame];		[NSGraphicsContext saveGraphicsState];		if([buttonCell isEnabled]) {				[[self dropShadow] set];	}		[[self darkStrokeColor] set];	[path setLineWidth: 1.0f];	[path stroke];		[NSGraphicsContext restoreGraphicsState];		//Draw Background	if([buttonCell isEnabled]) {				if(([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 14) ||		   ([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 12)) {						if([buttonCell state] == 1) {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] highlightComplexGradient] drawInBezierPath: path angle: 90];			} else {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalComplexGradient] drawInBezierPath: path angle: 90];			}		} else {						if([buttonCell isHighlighted]) {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] pushedComplexGradient] drawInBezierPath: path angle: 90];			} else {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalComplexGradient] drawInBezierPath: path angle: 90];			}		}	} else {				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] disabledNormalComplexGradient] drawInBezierPath: path angle: 90];	}		//Draw Border		if([buttonCell isEnabled]) {				[[self strokeColor] set];	} else {				[[self strokeColor] set];	}	[path setLineWidth: 1.0f];	[path stroke];		[path release];		if([buttonCell imagePosition] != NSImageOnly) {				[self drawTitle: [buttonCell attributedTitle] withFrame: frame inView: [buttonCell controlView]];	}		if([buttonCell imagePosition] != NSNoImage) {				[self drawImage: [buttonCell image] withFrame: frame inView: [buttonCell controlView]];	}}-(void)drawRoundRectButtonInFrame:(NSRect)frame{		//Adjust Rect so strokes are true and	//shadows are visible	frame.origin.x += 1.5f;	frame.size.width -= 3;		//Adjust Rect based on ControlSize so that	//my controls match as closely to apples	//as possible.	switch ([buttonCell controlSize]) {					case NSRegularControlSize:						frame.size.height -= 3;			break;					case NSSmallControlSize:						frame.size.height -= 3;			break;					case NSMiniControlSize:						frame.origin.y += 1;			frame.size.height -= 5;			break;	}		//Create Path	NSBezierPath *path = [[NSBezierPath alloc] init];		[path appendBezierPathWithArcWithCenter: NSMakePoint(NSMinX(frame) + BtnCenterY(frame), NSMidY(frame) + 0.5f)									 radius: BtnCenterY(frame)								 startAngle: 90								   endAngle: 270];		[path appendBezierPathWithArcWithCenter: NSMakePoint(NSMaxX(frame) - BtnCenterY(frame), NSMidY(frame) + 0.5f)									 radius: BtnCenterY(frame)								 startAngle: 270								   endAngle: 90];		[path closePath];	[NSGraphicsContext saveGraphicsState];		//Draw dark border color		if([buttonCell isEnabled]) {				[[self dropShadow] set];	}	[[self darkStrokeColor] set];	[path stroke];		[NSGraphicsContext restoreGraphicsState];		if([buttonCell isEnabled]) {				if(([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 14) ||		   ([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 12)) {						if([buttonCell state] == 1) {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] highlightGradient] drawInBezierPath: path angle: 90];			} else {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalGradient] drawInBezierPath: path angle: 90];			}		} else {						if([buttonCell isHighlighted]) {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] pushedGradient] drawInBezierPath: path angle: 90];			} else {								//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalGradient] drawInBezierPath: path angle: 90];			}		}	} else {				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] disabledNormalGradient] drawInBezierPath: path angle: 90];	}		if([buttonCell isEnabled]) {				[[self strokeColor] set];	} else {				[[self strokeColor] set];	}	[path setLineWidth: 1.0f];	[path stroke];		[path release];		if([buttonCell imagePosition] != NSImageOnly) {				NSRect textFrame = frame;		textFrame.origin.y += 1;				[self drawTitle: [buttonCell attributedTitle] withFrame: textFrame inView: [buttonCell controlView]];	}		if([buttonCell imagePosition] != NSNoImage) {				[self drawImage: [buttonCell image] withFrame: frame inView: [buttonCell controlView]];	}}-(void)drawTexturedRoundedButtonInFrame:(NSRect)frame{		//Adjust Rect so strokes are true and	//shadows are visible	frame.origin.x += 1.5f;	frame.origin.y += 0.5f;	frame.size.width -= 3;	frame.size.height -= 4;		//Adjust Rect based on ControlSize so that	//my controls match as closely to apples	//as possible.	switch ([buttonCell controlSize]) {					case NSRegularControlSize:						frame.origin.y += 1;			break;					case NSSmallControlSize:						frame.origin.y += 3;			frame.size.height += 2;			break;					case NSMiniControlSize:						frame.origin.y += 5;			frame.size.height += 1;			break;	}		//Draw Outer-most ring	NSBezierPath *path = [[NSBezierPath alloc] init];	//[path appendBezierPathWithRoundedRect: frame xRadius: 4.0f yRadius: 4.0f];	[path appendBezierPathWithRoundedRect: frame cornerRadius:6.0f];		//Save Graphics State	[NSGraphicsContext saveGraphicsState];		if([buttonCell isEnabled]) {				[[self dropShadow] set];	}		//Draw Dark Border	/*	 [[self darkStrokeColor] set];	 [path setLineWidth: 1.0f];	 [path stroke];	 */	//Restore Graphics State	[NSGraphicsContext restoreGraphicsState];		[self drawShadingWithStartingColor: [self colorVlaueWithRed: 239 green: 239 blue: 239]//[NSColor blackColor]					   withEndingColor: [self colorVlaueWithRed: 93 green: 93 blue: 93]//[NSColor whiteColor]						  inBezierPath: path];		/*NSString *imageFile = [[NSBundle bundleForClass:[self class]] pathForImageResource: @"graybutton.png"];	 NSImage *buttonImage = [[NSImage alloc] initWithContentsOfFile: imageFile];	 [buttonImage drawInRect:frame fromRect: NSZeroRect operation: NSCompositeSourceAtop fraction:1.0];		 [buttonImage release];*/		if([buttonCell isEnabled]) {				//Draw Background		if(([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 14) ||		   ([buttonCell showsStateBy] == 12 && [buttonCell highlightsBy] == 12)) {						if([buttonCell state] == 1) 			{				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] highlightGradient] drawInBezierPath: path angle: 90];			} 			else			{				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalGradient] drawInBezierPath: path angle: 90];			}		}		else 		{			if([buttonCell isHighlighted])			{				[NSGraphicsContext saveGraphicsState];				[[self colorVlaueWithRed: 246 green: 186 blue: 55] set];				[path setLineWidth: 3.0f];				[path stroke];						[NSGraphicsContext restoreGraphicsState];				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] pushedGradient] drawInBezierPath: path angle: 90];			}			else			{				//[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] normalGradient] drawInBezierPath: path angle: 90];			}		}	} 	else	{		//	[[[[BGThemeManager keyedManager] themeForKey: self.themeKey] disabledNormalGradient] drawInBezierPath: path angle: 90];	}		//Draw Border	/*	 if([self isEnabled]) {	 	 [[self strokeColor] set];	 } else {	 	 [[self strokeColor] set];	 }	 	 [path setLineWidth: 1.0f];	 [path stroke];	 */	//path = nil;	[path release];		if([buttonCell imagePosition] != NSImageOnly) {				[buttonCell drawTitle: [buttonCell attributedTitle] withFrame: frame inView: [buttonCell controlView]];	}		if([buttonCell imagePosition] != NSNoImage) {				[self drawImage: [buttonCell image] withFrame: frame inView: [buttonCell controlView]];	}}-(void)drawHelpButtonInFrame:(NSRect)frame {	//NSLog(@"drawHelpButtonInFrame");}- (NSRect)drawTitle:(NSAttributedString *)title withFrame:(NSRect)frame inView:(NSView *)controlView {		NSRect textRect = frame;	NSColor *titleColor = nil;		//[self setFont: [NSFont fontWithName: @"Arial" size: 12.0]];		// Adjust Text Rect based on control type and size	if([[_normalImage name] isEqualToString: @"NSSwitch"] ||	   [[_normalImage name] isEqualToString: @"NSRadioButton"] ||	   [[[buttonCell controlView] className] isEqualToString: @"NSMatrix"])	{		//We aren't going to do anything here		titleColor = [self colorVlaueWithRed: 207 green: 207 blue: 207];//[NSColor whiteColor];[];	} else {				//textRect.origin.x += 5;		//textRect.origin.y -= 1;		//textRect.size.width -= 10;		//textRect.size.height += 0;	}		NSMutableAttributedString *newTitle = [title mutableCopy];		//If button is set to show alternate title then	//display alternate title	if([buttonCell showsStateBy] == 0 && [buttonCell highlightsBy] == 1) {				if([buttonCell isHighlighted]) {						if([buttonCell alternateTitle]) {								[newTitle setAttributedString: [buttonCell attributedAlternateTitle]];			}		}	}		//If button is set to show alternate title then	//display alternate title	if([buttonCell showsStateBy] == 1 && [buttonCell highlightsBy] == 3) {				if([buttonCell state] == 1) {						if([buttonCell alternateTitle]) {								[newTitle setAttributedString: [buttonCell attributedAlternateTitle]];			}		}	}		//Make sure we aren't trying to edit an	//empty string.	if([newTitle length] > 0) {				[newTitle beginEditing];				[newTitle removeAttribute: NSShadowAttributeName							range: NSMakeRange(0, [newTitle length])];				[newTitle addAttribute: NSFontAttributeName						 value: [NSFont fontWithName: @"Arial" size: 12.0]						 range: NSMakeRange(0, [newTitle length])];							//Set text color based on button enabled state.		if([buttonCell isEnabled]) {			if (!titleColor) titleColor = [self colorVlaueWithRed: 36 green: 36 blue: 36];			[newTitle addAttribute: NSForegroundColorAttributeName							 value: titleColor							 range: NSMakeRange(0, [newTitle length])];		} else {						[newTitle addAttribute: NSForegroundColorAttributeName							 value: [self colorVlaueWithRed: 113 green: 113 blue: 113]							 range: NSMakeRange(0, [newTitle length])];		}				[newTitle endEditing];				//Make the super class do the drawing				//TBD		[newTitle drawInRect:textRect];		//[super drawTitle: newTitle withFrame: textRect inView: controlView];	}		[newTitle release];	return textRect;}- (void)drawBezelWithFrame:(NSRect)frame inView:(NSView *)controlView{	if ([[_normalImage name] isEqualToString: @"NSRadioButton"])		NSLog(@"drawBezelWithFrame");}@end